#!/usr/bin/env node

/*****************************************************************
 * Packmate - Simple dependency update & unused checker
 * (c) 2025-present AGUMON (https://github.com/ljlm0402/packmate)
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the project root for more information.
 *
 * Made with ‚ù§Ô∏è by AGUMON ü¶ñ
 *****************************************************************/

import { intro, outro, note, spinner } from '@clack/prompts';
import chalk from 'chalk';
import depcheck from 'depcheck';
import fs from 'fs';
import { createRequire } from 'module';
import path from 'path';
import process from 'process';
import { getUpdateCandidates } from '../src/update-checker.js';
import { runUnusedCheck } from '../src/unused-checker.js';
import { detectPackageManager } from '../src/detect-package-manager.js';
import { installPackages, uninstallPackages } from '../src/install-helper.js';
import { runWithWarningCapture } from '../src/warning-capture.js';
import { loadConfig } from '../src/config-loader.js';
import {
  updateAvailableSession,
  unusedSession,
  notInstalledSession,
  latestSession,
} from '../src/ui-sessions.js';

const require = createRequire(import.meta.url);

/**
 * ÏÑ§ÏπòÎêú Ìå®ÌÇ§ÏßÄÏùò ÌòÑÏû¨ Î≤ÑÏ†ÑÏùÑ Í∞ÄÏ†∏ÏòµÎãàÎã§
 */
function getCurrentVersion(dep) {
  // Î∞©Î≤ï 1: ÌëúÏ§Ä node_modules ÏúÑÏπò ÌôïÏù∏ (npm, yarn, pnpmÏùò node-linker=hoistedÏóêÏÑú ÏûëÎèô)
  try {
    const pkgPath = path.resolve(process.cwd(), 'node_modules', dep, 'package.json');
    if (fs.existsSync(pkgPath)) {
      const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'));
      return pkg.version;
    }
  } catch (err) {
    // Îã§Ïùå Î∞©Î≤ïÏúºÎ°ú Í≥ÑÏÜç
  }

  // Î∞©Î≤ï 2: pnpmÏùò .pnpm ÎîîÎ†âÌÜ†Î¶¨ ÌôïÏù∏ (node-linker=isolatedÏù∏ pnpmÏö©)
  try {
    const pnpmDir = path.resolve(process.cwd(), 'node_modules', '.pnpm');
    if (fs.existsSync(pnpmDir)) {
      const entries = fs.readdirSync(pnpmDir);
      // @clack/prompts Í∞ôÏùÄ Ïä§ÏΩîÌîÑ Ìå®ÌÇ§ÏßÄ Ï≤òÎ¶¨
      const depName = dep.replace('/', '+');
      const found = entries.find((f) => f.startsWith(depName + '@'));
      if (found) {
        const pkgPath = path.resolve(pnpmDir, found, 'node_modules', dep, 'package.json');
        if (fs.existsSync(pkgPath)) {
          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'));
          return pkg.version;
        }
      }
    }
  } catch (err) {
    // Îã§Ïùå Î∞©Î≤ïÏúºÎ°ú Í≥ÑÏÜç
  }

  // Î∞©Î≤ï 3: require.resolve ÏãúÎèÑ (ÏùºÎ∂Ä ESM ÏãúÎÇòÎ¶¨Ïò§ÏóêÏÑúÎäî ÏûëÎèôÌïòÏßÄ ÏïäÏùÑ Ïàò ÏûàÏùå)
  try {
    const mainPath = require.resolve(`${dep}/package.json`, { paths: [process.cwd()] });
    if (mainPath && fs.existsSync(mainPath)) {
      const pkg = JSON.parse(fs.readFileSync(mainPath, 'utf-8'));
      return pkg.version;
    }
  } catch (err) {
    // Ìå®ÌÇ§ÏßÄÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå
  }

  return null;
}

/**
 * ÏÑ†Ïñ∏ÎêòÏóàÏßÄÎßå ÏÑ§ÏπòÎêòÏßÄ ÏïäÏùÄ Ìå®ÌÇ§ÏßÄ Î™©Î°ùÏùÑ Í∞ÄÏ†∏ÏòµÎãàÎã§
 */
function getNotInstalledPackages() {
  const pkgPath = path.resolve(process.cwd(), 'package.json');
  if (!fs.existsSync(pkgPath)) return [];

  const pkgJson = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'));
  const allDeps = { ...pkgJson.dependencies, ...pkgJson.devDependencies };
  const notInstalled = [];

  for (const dep of Object.keys(allDeps)) {
    const version = getCurrentVersion(dep);
    if (!version) {  // nullÏùÄ Ï∞æÏùÑ Ïàò ÏóÜÏùåÏùÑ ÏùòÎØ∏
      notInstalled.push(dep);
    }
  }

  return notInstalled;
}

async function main() {
  intro(chalk.cyan('üì¶ Packmate: Dependency Updates & Cleanup'));

  // ÏÑ§Ï†ï Î°úÎìú
  const config = loadConfig();

  // node_modules ÌôïÏù∏
  const nodeModulesPath = path.resolve(process.cwd(), 'node_modules');
  if (!fs.existsSync(nodeModulesPath)) {
    note(
      chalk.yellow(
        '‚ö†Ô∏è  The node_modules directory is missing. Please install dependencies first (npm/yarn/pnpm install).',
      ),
      'Warning',
    );
    process.exit(0);
  }

  const packageManager = detectPackageManager();
  note(chalk.dim(`Package Manager: ${packageManager}`), 'Info');

  const s = spinner();

  // 1. ÎØ∏ÏÇ¨Ïö© Ìå®ÌÇ§ÏßÄ Î®ºÏ†Ä Î∂ÑÏÑù (ÏóÖÎç∞Ïù¥Ìä∏ ÌïÑÌÑ∞ÎßÅÏö©)
  s.start('Analyzing unused packages...');
  const unused_precinct = await runUnusedCheck({ withUsedList: true });

  // depcheckÎ°ú ÍµêÏ∞® Í≤ÄÏ¶ù
  const depcheckResult = await depcheck(process.cwd(), {});
  const unused_depcheck = depcheckResult.dependencies || [];
  s.stop('‚úÖ Unused package analysis complete');

  // Ïã†Î¢∞ÎèÑÎ≥Ñ Î∂ÑÎ•ò
  const bothUnused = unused_precinct.unused.filter((x) => unused_depcheck.includes(x));
  const onlyPrecinct = unused_precinct.unused.filter((x) => !unused_depcheck.includes(x));
  const onlyDepcheck = unused_depcheck.filter((x) => !unused_precinct.unused.includes(x));

  // ÌïÑÌÑ∞ÎßÅÏùÑ ÏúÑÌïú Î™®Îì† ÎØ∏ÏÇ¨Ïö© Ìå®ÌÇ§ÏßÄ Ïù¥Î¶Ñ Í∞ÄÏ†∏Ïò§Í∏∞
  const allUnusedNames = [...bothUnused, ...onlyPrecinct, ...onlyDepcheck];

  // 2. ÏóÖÎç∞Ïù¥Ìä∏ Í∞ÄÎä•Ìïú Ìå®ÌÇ§ÏßÄ Î∂ÑÏÑù (ÎØ∏ÏÇ¨Ïö© Ìå®ÌÇ§ÏßÄ Ï†úÏô∏)
  s.start('Checking for available updates...');
  const allUpdateCandidates = await getUpdateCandidates(packageManager);

  // ÏóÖÎç∞Ïù¥Ìä∏ ÌõÑÎ≥¥ÏóêÏÑú ÎØ∏ÏÇ¨Ïö© Ìå®ÌÇ§ÏßÄ ÌïÑÌÑ∞ÎßÅ
  const updateCandidates = allUpdateCandidates.filter(
    (candidate) => !allUnusedNames.includes(candidate.name)
  );
  s.stop(`‚úÖ Found ${updateCandidates.length} packages with available updates`);

  const unusedPackages = [
    ...bothUnused.map((dep) => ({
      name: dep,
      current: getCurrentVersion(dep),
      confidence: 'high',
      hint: 'Detected by both precinct and depcheck',
    })),
    ...onlyPrecinct.map((dep) => ({
      name: dep,
      current: getCurrentVersion(dep),
      confidence: 'medium',
      hint: 'Detected by precinct only',
    })),
    ...onlyDepcheck.map((dep) => ({
      name: dep,
      current: getCurrentVersion(dep),
      confidence: 'medium',
      hint: 'Detected by depcheck only',
    })),
  ];

  // 3. ÎØ∏ÏÑ§Ïπò Ìå®ÌÇ§ÏßÄ ÌôïÏù∏
  s.start('Checking for not installed packages...');
  const notInstalled = getNotInstalledPackages();
  s.stop(`‚úÖ Found ${notInstalled.length} not installed packages`);

  const notInstalledPackages = notInstalled.map((dep) => ({
    name: dep,
    current: '-',
    latest: '-',
  }));

  // 4. ÏµúÏã† Î≤ÑÏ†Ñ Ìå®ÌÇ§ÏßÄ
  const pkgJson = JSON.parse(fs.readFileSync(path.resolve(process.cwd(), 'package.json'), 'utf-8'));
  const declared = { ...pkgJson.dependencies, ...pkgJson.devDependencies };
  const latestPackages = [];

  for (const dep of Object.keys(declared)) {
    const isUpdatable = updateCandidates.some((c) => c.name === dep);
    const isUnused = unusedPackages.some((u) => u.name === dep);
    const isNotInstalled = notInstalledPackages.some((n) => n.name === dep);

    if (!isUpdatable && !isUnused && !isNotInstalled) {
      const current = getCurrentVersion(dep);
      if (current && current !== '-') {
        latestPackages.push({
          name: dep,
          current,
          latest: current,
        });
      }
    }
  }

  // === Î∂ÑÏÑù Í≤∞Í≥º ÏöîÏïΩ ===
  // console.logÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Îçî ÎÇòÏùÄ Ìè¨Îß∑ÌåÖ
  console.log('\n' + chalk.cyan.bold('üìä Analysis Results:'));
  console.log(chalk.cyan(`   Updates available: ${updateCandidates.length}`));
  console.log(chalk.cyan(`   Unused:            ${unusedPackages.length}`));
  console.log(chalk.cyan(`   Not installed:     ${notInstalledPackages.length}`));
  console.log(chalk.cyan(`   Up-to-date:        ${latestPackages.length}`));

  const selectedActions = [];

  // === Í∑∏Î£πÎ≥Ñ UI ÏÑ∏ÏÖò Ïã§Ìñâ ===
  if (config.ui?.groupSessions) {
    // 1. ÏóÖÎç∞Ïù¥Ìä∏ Í∞ÄÎä• ÏÑ∏ÏÖò
    if (updateCandidates.length > 0) {
      const updateSelected = await updateAvailableSession(updateCandidates, config);
      selectedActions.push(...updateSelected);
    }

    // 2. ÎØ∏ÏÇ¨Ïö© Ìå®ÌÇ§ÏßÄ ÏÑ∏ÏÖò
    if (unusedPackages.length > 0) {
      const unusedSelected = await unusedSession(unusedPackages, config);
      selectedActions.push(...unusedSelected);
    }

    // 3. ÎØ∏ÏÑ§Ïπò Ìå®ÌÇ§ÏßÄ ÏÑ∏ÏÖò
    if (notInstalledPackages.length > 0) {
      const notInstalledSelected = await notInstalledSession(notInstalledPackages, config);
      selectedActions.push(...notInstalledSelected);
    }

    // 4. ÏµúÏã† Î≤ÑÏ†Ñ Ìå®ÌÇ§ÏßÄ ÏÑ∏ÏÖò (ÏÑ†ÌÉù ÏÇ¨Ìï≠)
    if (latestPackages.length > 0) {
      await latestSession(latestPackages, config);
    }
  } else {
    note(
      chalk.yellow('‚ö†Ô∏è  groupSessions is disabled in config. Refer to packmate.js.backup for legacy mode.'),
      'Info',
    );
  }

  // === ÏûëÏóÖ Ïã§Ìñâ ===
  if (selectedActions.length === 0) {
    note(chalk.yellow('No actions selected.'), 'Info');
    outro(chalk.bold.cyan('Packmate complete! üëã'));
    return;
  }

  note(
    chalk.cyan(
      `\nüìù Actions to execute:\n${selectedActions.map((a) => `  - ${a.action}: ${a.name}${a.latestVersion ? '@' + a.latestVersion : ''}`).join('\n')}`,
    ),
    'Actions',
  );

  // ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìñâ
  const toUpdate = selectedActions.filter((a) => a.action === 'update');
  for (const item of toUpdate) {
    let cmd, args;
    switch (packageManager) {
      case 'pnpm':
        cmd = 'pnpm';
        args = ['add', `${item.name}@${item.latestVersion}`];
        break;
      case 'yarn':
        cmd = 'yarn';
        args = ['add', `${item.name}@${item.latestVersion}`];
        break;
      case 'npm':
      default:
        cmd = 'npm';
        args = ['install', `${item.name}@${item.latestVersion}`];
        break;
    }

    note(chalk.cyan(`${cmd} ${args.join(' ')}`), 'Command');
    const { code, warnings } = await runWithWarningCapture(cmd, args);

    if (code === 0) {
      note(chalk.green(`‚úîÔ∏è  Update complete: ${item.name}@${item.latestVersion}`), 'Success');
    } else {
      note(chalk.red(`‚ùå Update failed: ${item.name}@${item.latestVersion}`), 'Failed');
    }

    if (warnings.length) {
      note(chalk.yellow(`‚ö†Ô∏è  Warnings:\n${warnings.map((w) => '  - ' + w).join('\n')}`), 'Warning');
    }
  }

  // Ï†úÍ±∞ Ïã§Ìñâ
  const toRemove = selectedActions.filter((a) => a.action === 'remove').map((a) => a.name);
  if (toRemove.length > 0) {
    uninstallPackages(toRemove, packageManager);
  }

  // ÏÑ§Ïπò Ïã§Ìñâ
  const toInstall = selectedActions.filter((a) => a.action === 'install').map((a) => a.name);
  if (toInstall.length > 0) {
    installPackages(toInstall, packageManager);
  }

  // ÏµúÏ¢Ö ÏöîÏïΩ - console.logÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Îçî ÎÇòÏùÄ Ìè¨Îß∑ÌåÖ
  console.log('\n' + chalk.green.bold('‚úÖ Complete:'));
  console.log(chalk.green(`   Updated:   ${toUpdate.length}`));
  console.log(chalk.green(`   Removed:   ${toRemove.length}`));
  console.log(chalk.green(`   Installed: ${toInstall.length}`));

  outro(chalk.bold.cyan('Packmate complete! üéâ'));
}

main().catch((error) => {
  console.error(chalk.red('Error occurred:'), error);
  process.exit(1);
});
